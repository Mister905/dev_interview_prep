<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>React Cardio Exercises</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
      :root {
        --bg: #0b0f0d;
        --surface: #121816;
        --text: #e6f0ea;
        --muted: #a7b8af;
        --accent: #2ecc71;
        --border: #1f2a25;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 32px;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        line-height: 1.6;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 8px;
        color: var(--accent);
      }
      h2 {
        font-size: 1.4rem;
        margin-top: 40px;
        margin-bottom: 12px;
        color: var(--accent);
        border-bottom: 1px solid var(--border);
        padding-bottom: 6px;
      }
      h3 {
        font-size: 1.1rem;
        margin-top: 24px;
        margin-bottom: 8px;
        color: var(--accent);
      }
      h4 {
        font-size: 1rem;
        margin-top: 16px;
        margin-bottom: 6px;
        color: var(--accent);
      }

      p {
        margin: 8px 0;
        color: var(--text);
      }

      ul {
        margin: 8px 0 8px 20px;
        padding: 0;
      }
      li {
        margin-bottom: 6px;
        color: var(--text);
      }

      .muted {
        color: var(--muted);
      }

      .block {
        background-color: var(--surface);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 16px 20px;
        margin-top: 12px;
      }

      .quote {
        border-left: 3px solid var(--accent);
        padding-left: 14px;
        margin: 12px 0;
        color: var(--text);
      }

      strong {
        color: var(--accent);
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>React Cardio Exercises</h1>

      <section>
      <h2>Task 1: UserSearch Component</h2>
      <p>Build a component that fetches and filters users by name.</p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li>Fetch users from an external API on initial load</li>
        <li>Display a list of users showing name and email</li>
        <li>Allow the user to filter by name using an input field</li>
        <li>Filter results in real time as the user types</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>Use functional components with React Hooks</li>
        <li>Use TypeScript for all state and data typing</li>
        <li>
          Create a <code>User</code> interface with at least <code>id</code>,
          <code>name</code>, and <code>email</code>
        </li>
        <li>Handle loading and error states</li>
        <li>Use a stable <code>key</code> when rendering lists</li>
      </ul>

      <h3>API Endpoint:</h3>
      <code>https://jsonplaceholder.typicode.com/users</code>

      <p class="note">
        You only need to use <code>id</code>, <code>name</code>, and
        <code>email</code> from each user object.
      </p>

      <p class="note">
        This component fetches user data on mount using axios, handles loading
        and error states, and lets the user filter the list in real-time using
        an input box. I used useState to track both the original and filtered
        user arrays, and useEffect to update the filtered list when the query
        changes. TypeScript enforces structure, especially with the User
        interface, and everything is wrapped in a functional React component.
      </p>
    </section>

    <section>
      <h2>Task 2: Counter Component</h2>
      <p>
        Create a simple counter that displays a number and provides buttons to
        increment and decrement the value.
      </p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li>Start from 0</li>
        <li>Increment with a "+" button</li>
        <li>Decrement with a "−" button</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>Use <code>useState</code> to manage the count</li>
        <li>Use TypeScript for typing the state variable</li>
      </ul>

      <p class="note">
        This is a simple <Counter /> component that uses useState to track a
        numeric count. I added a guard in handleDecrement to prevent the value
        from going below zero. I prefer extracting this logic into a separate
        function to keep event handlers readable and testable. The + and −
        buttons use arrow functions to update the state safely via the previous
        value.
      </p>
    </section>

    <section>
      <h2>Task 3: Parent and Child Components</h2>
      <p>Create two components that demonstrate communication via props.</p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li><code>Child</code> component contains a text input</li>
        <li>When the input changes, it calls a callback function passed via props</li>
        <li><code>Parent</code> receives and displays the value</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>Use interface-based props for both components</li>
        <li>Ensure all props and state are typed in TypeScript</li>
        <li>Use controlled input in the child</li>
      </ul>

      <p class="note">
        In this task, I created two components — a Parent and a Child — to
        demonstrate bidirectional communication using interface-based props in
        React with TypeScript.
      </p>
    </section>

    <section>
      <h2>Task 4: BlogPost Component (Object and Array Props)</h2>
      <p>
        Create a component accepting an <code>author</code> object and a list of
        <code>tags</code>.
      </p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li>Display author's name and bio</li>
        <li>Render tags as a list</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>
          Use separate TypeScript interfaces for author and blog post props
        </li>
        <li>Type the tags as an array of strings</li>
        <li>Use a stable key when rendering the tags list</li>
      </ul>

      <p class="note">
        I structured the prop types using two interfaces: Author and
        BlogPostProps. Then I destructured the author object directly in the
        function parameters for clarity. The tags array is mapped into list
        items, each with a key based on the index. This helps React efficiently
        update the DOM when the list changes.
      </p>
    </section>

    <h2>Bonus</h2>

    <section>
      <h2>Task 5: ProfileCard Component (Primitive Props)</h2>
      <p>
        Build a component that accepts simple primitive props:
        <code>username</code>, <code>age</code>, and <code>isVerified</code>.
      </p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li>Display the username and age</li>
        <li>Display a visual indication if the user is verified</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>Use TypeScript interface for props</li>
        <li>Use a boolean prop for verification status</li>
      </ul>

      <p class="note">
        In this component, I’m rendering a ProfileCard that receives props for a
        username, age, and whether the user is verified. I used an interface
        ProfileCardProps to strongly type the props, ensuring type safety and
        clear expectations for the parent component. Inside the component, I
        render each prop and use a ternary condition to convert the boolean
        isVerified to a user-friendly 'Y' or 'N'. This is a good example of how
        I structure simple, stateless components with clean prop contracts,
        which makes them reusable and easy to test.
      </p>
    </section>

    <section>
      <h2>Task 6: StringListForm Component (Form Handling, Debouncing, and Submission Guarding)</h2>
      <p>
        Build a React component that manages a list of strings added via a text input
        and a submit button, with additional safeguards to reflect real-world form behavior.
      </p>

      <h3>Functional Requirements</h3>
      <ul>
        <li>Provide a controlled text input and a submit button</li>
        <li>Allow users to add strings to an internal list via form submission</li>
        <li>Display the full list of submitted strings</li>
        <li>Show a running message indicating how many strings have been added</li>
        <li>The count message should update immediately after each successful submission</li>
        <li>Prevent duplicate or invalid submissions</li>
        <li>Avoid triggering validation or side effects on every keystroke</li>
      </ul>

      <h3>Enhanced Behavior Requirements</h3>

      <h4>Debounced Input Handling</h4>
      <ul>
        <li>User input should update immediately in the UI</li>
        <li>Validation or derived logic (e.g., trimming, duplicate detection, preview state) should be debounced</li>
        <li>Debounced logic should only run after the user pauses typing (e.g., 300–500ms)</li>
        <li>Any pending validation should be canceled if the input changes</li>
      </ul>

      <h4>Duplicate Submission Prevention</h4>
      <ul>
        <li>Only one submission may be processed at a time</li>
        <li>While a submission is in progress:
          <ul>
            <li>The submit button should be disabled</li>
            <li>Additional submit attempts should be ignored</li>
          </ul>
        </li>
        <li>Once the submission completes, the form becomes interactive again</li>
      </ul>

      <h3>Technical Requirements</h3>
      <ul>
        <li>Use <code>useState</code> to manage:
          <ul>
            <li>The input value</li>
            <li>The list of submitted strings</li>
            <li>Submission/loading state</li>
            <li>Any debounced or derived input state</li>
          </ul>
        </li>
        <li>Use the functional state update form:
          <code>setStringList(prev =&gt; [...prev, value])</code>
        </li>
        <li>Handle form submission using <code>onSubmit</code> and prevent page reload</li>
        <li>Create a custom <code>useDebounce</code> hook that takes 2 arguments (text, delay) and returns debounced text value</li>
        <li>Use TypeScript for all typing</li>
        <li>Trim whitespace and ignore empty submissions</li>
        <li>Clear the input after a successful submission</li>
      </ul>

      <p class="note">
        This component allows users to input strings via a form and submit them to a list
        managed in component state. Input is controlled and validated in a debounced manner
        to avoid unnecessary processing on every keystroke. Form submission is guarded to
        prevent duplicate requests, ensuring that only one submission can occur at a time.
        The component displays the full list of submitted strings along with a running count
        that updates immediately after each valid submission.
      </p>
      <p class="note">
        This design mirrors real-world form behavior by balancing responsiveness,
        correctness, and user experience.
      </p>
    </section>

    <section>
      <h2>Task 7: Tic-Tac-Toe</h2>
      <p>
        Build a playable Tic-Tac-Toe game with a 3×3 board, two players (X and
        O), and winner detection.
      </p>

      <h3>Functional Requirements:</h3>
      <ul>
        <li>Render a 3×3 grid of clickable squares</li>
        <li>Alternate turns between X and O on each click</li>
        <li>Display whose turn is next (e.g. "Next player: X")</li>
        <li>Detect and display the winner when three in a row (any line) are the same</li>
        <li>Prevent clicking an already filled square or making moves after the game is won</li>
      </ul>

      <h3>Technical Requirements:</h3>
      <ul>
        <li>Use <code>useState</code> to manage the board state (array of 9 values) and current player</li>
        <li>Lift state up so the parent (e.g. <code>Board</code>) owns the squares and passes <code>value</code> and <code>onSquareClick</code> to each square</li>
        <li>Use a <code>Square</code> component that accepts <code>value</code> and <code>onSquareClick</code> props</li>
        <li>Implement winner calculation (all 8 winning lines) and derive status text from it</li>
        <li>Use TypeScript for all state, props, and the winner logic</li>
      </ul>

      <p class="note">
        <strong>Hint:</strong> You can initialize the board state with
        <code>Array(9).fill(null)</code>.
      </p>

      <p class="note">
        I built a Board component that holds the squares array and xIsNext in
        state, and a Square component that receives value and onSquareClick via
        props. The board updates a copy of the squares array on click and toggles
        xIsNext, with guards to ignore clicks on filled squares or after a
        winner. I used a calculateWinner helper that checks the eight winning
        lines and returns the winning mark or null, then derived the status
        message from that. Typed everything with TypeScript interfaces for the
        Square props and the squares array.
      </p>
    </section>
  </body>
</html>
